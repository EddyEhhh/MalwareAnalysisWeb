package edu.mac.malwarereport.report.upload;

import java.io.*;
import java.util.concurrent.TimeoutException;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.security.*;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.ConsumerShutdownSignalCallback;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.rabbitmq.client.ShutdownSignalException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.Marker;

import org.apache.logging.log4j.MarkerManager;
import org.apache.logging.log4j.ThreadContext;
import org.apache.logging.log4j.core.LoggerContext;
import org.json.JSONObject;



// Houses the name of the consumer and the queue it consumes from
class ConsumerInfo {
    String queue;
    String name;

    public ConsumerInfo(String queueName, String consumerName) {
        queue = queueName;
        name = consumerName;
    }

    // Returns this String when the ConsumerInfo object printed
    @Override
    public String toString() {
        return "\'" + name + "\' to consume from queue \'" + queue + "\'";
    }
}


// Takes in ConsumerInfo object as a parameter; Able to access contents of ConsumerInfo
// Starts message consumption from the Queue specified in the ConsumerInfo object
class newConsumer implements Runnable {
    ConsumerInfo consumerInfo;

    public newConsumer(ConsumerInfo consumerInfo) {
        this.consumerInfo = consumerInfo;
    }

    @Override
    public void run() {
        Thread.currentThread().setName(consumerInfo.queue + " Consumer");
        RabbitMQ.Message.consume(consumerInfo.queue, consumerInfo.name);

//        System.out.println("Thread: " + Thread.currentThread().getName() + " | State: " + Thread.currentThread().getState());
//        StackTraceElement[] ste = Thread.currentThread().getStackTrace();
//        for (StackTraceElement stacktrace : ste) {
//            System.out.println(stacktrace);
//        }
//        System.out.println();
    }
}



class RabbitMQ {

    //File log4j2ConfigFile = new File("D:/MP Stuff/MP/MLAB Major Project G22/report-ejb/src/main/resources/META-INF/log4j2.xml");
    
    // Declares a logger object
    private static Logger LOGGER = LogManager.getLogger(RabbitMQ.class);
    private static Marker IMPORTANT = MarkerManager.getMarker("IMPORTANT");

    public static ArrayList<ConsumerInfo> consumerList = new ArrayList<ConsumerInfo>();
    public static boolean intentionalClose = false;
    public static Connection connection;
    public static Channel channel;


    public static ConnectionFactory newConnFactory(String username, String password, String keyStorePath, String trustStorePath) {
        ConnectionFactory factory = null;
        try {
            factory = new ConnectionFactory();
            // Defines RabbitMQ connection parameters
            factory.setUsername(username);
            factory.setPassword(password);
            factory.setUri("amqp://10.242.248.7");
            // Connect with TLS
            factory.setPort(5671);
            factory.useSslProtocol(TLS.sslContext(TLS.keyStore(keyStorePath), TLS.trustStore(trustStorePath)));
            // Default value is True; Automatic Recovery is enabled by default
            factory.setAutomaticRecoveryEnabled(false);
            factory.setTopologyRecoveryEnabled(false);

            // Hostname Verification causes issue with connecting as it's trying to verify if VM is localhost
            //factory.enableHostnameVerification();
        }
        catch (Exception uriException) {
            System.out.println(uriException.getMessage());
        }
        return factory;
    }


    // Connects to RabbitMQ; Continuously attempts to connect if failed
    // Creates a Connection shutdown listener
    // Segways to create Channel
    public static void connect(ConnectionFactory factory, byte connectCount) {
        try {
	    LOGGER.info("Attempting to connect to RabbitMQ...");
            // Connects to RabbitMQ
            connection = factory.newConnection();
            LOGGER.info("Connected to RabbitMQ");

            // Closes Channel when Connection is closed
            // Reconnects back to RabbitMQ if connection closure was not user initiated and prints the reason for closure
            connection.addShutdownListener((ShutdownSignalException connShutdown) -> {
		Thread.currentThread().setName("Connection Shutdown Listener");
                if (connShutdown.isHardError()) {
                    closeChannel();
                    if (!intentionalClose) {
			LOGGER.warn(IMPORTANT, "Unintentional closure of RabbitMQ connection '{}'. Connection will be re-established", connShutdown.getReference());
                        LOGGER.warn(IMPORTANT, "Reason: {}", connShutdown.getReason());
                        connect(factory, (byte)1);
                    }
		    else {
			LOGGER.error(IMPORTANT, "Intentional closure of RabbitMQ connection '{}'. Connection will NOT be restablished", connShutdown.getReference());
		    }
                }
            });

            // Proceeds to create a channel
            createChannel();
        }
        // Catches connection failures; socket down or connection timeout I think
        catch (java.net.ConnectException | TimeoutException connectionException) {
            reconnect(factory, connectCount);
        }
        // Catches exceptions when connecting to RabbitMQ
        catch (IOException connectionException) {
            System.out.println(connectionException);
            closeConnection();
        }
    }


    // Closes connection if it is open
    private static void closeConnection () {
        if (connection.isOpen()) {
	    LOGGER.info("Closing RabbitMQ connection...");
            try {
                connection.close();
            }
            catch (IOException connectionCloseException) {
                System.out.println(connectionCloseException);
            }
        }
    }


    // Creates a Channel
    // Enables Publisher Confirms
    // Creates a Channel shutdown listener
    // Segways to declare a Queue
    private static void createChannel() {
        try {
            // Creates a channel
            channel = connection.createChannel();
            LOGGER.info("Opened RabbitMQ Channel {}", channel.getChannelNumber());

            // Enable Publisher Confirms
            channel.confirmSelect();
            // Enables each Consumer to consume up to a maximum of 5 unacked messages at a time
            channel.basicQos(5, false);
            channel.addConfirmListener((messageId, multipleMessages) -> {
		Thread.currentThread().setName("Pubisher Confirms Listener");
                // code when messages is confirmed
                // SQL Code from Eddy here
                LOGGER.info("Message #{} received by server", messageId);
            },
            (messageId, multipleMessages) -> {
		Thread.currentThread().setName("Pubisher Confirms Listener");
                // code when message is nack-ed
                LOGGER.warn(IMPORTANT, "Message #{} not received by server", messageId);
            });


            // Closes connection when channel is closed, triggering Connection shutdownlistener
            // Prints the reason for Channel closure if it was not user initiated
            channel.addShutdownListener((ShutdownSignalException chanShutdown) -> {
		Thread.currentThread().setName("Channel Shutdown Listener");
                if (!chanShutdown.isHardError()) {
                    if (!intentionalClose) {
			LOGGER.warn(IMPORTANT, "Unintentional closure of RabbitMQ {}. Proceeding to close & re-establish RabbitMQ connection", chanShutdown.getReference());
                        LOGGER.warn(IMPORTANT, "Reason: {}", chanShutdown.getReason());
                    }
		    else {
			LOGGER.error(IMPORTANT, "Intentional closure of RabbitMQ {}. Proceeding to close RabbitMQ connection. Connection will NOT be re-established", chanShutdown.getReference());
		    }
		    closeConnection();
                }
            });

            // Proceeds to declare the necessary queues
            declareQueue();
        }
        // Catches exceptions when creating the channel or queues
        catch (IOException channelqueueException) {
            System.out.println(channelqueueException);
            closeConnection();
        }
    }


    // Closes channel if it is open
    public static void closeChannel () {
        if (channel.isOpen()) {
            LOGGER.info("Closing RabbitMQ channel...");
            try {
                channel.close();
            }
            catch (IOException | TimeoutException channelCloseException) {
                System.out.println(channelCloseException);
            }
        }
    }


    // For each ConsumerInfo object in "consumerList", declares the specified Queue, creating it if non-existent
    // Segways to setup Consumers
    private static void declareQueue() throws IOException {
        Map<String, Object> queueArgs = new HashMap<>();
        queueArgs.put("x-queue-mode", "lazy");

        for (ConsumerInfo consumerInfo : consumerList) {
            // Declares a queue that is durable, not exclusive, not auto-deleted, and lazy
            channel.queueDeclare(consumerInfo.queue, true, false, false, queueArgs);
            LOGGER.info("Declared RabbitMQ queue '{}'", consumerInfo.queue);
        }

        startConsumer();
    }


    // For each ConsumerInfo object in "consumerList", consumes messages from the specified Queue in a new thread
    // Passes each ConsumerInfo object into the newConsumer object
    private static void startConsumer() {
        for (ConsumerInfo consumerInfo : consumerList) {
            LOGGER.info("Setting up {}...", consumerInfo);

            Runnable newConsumerThread = new newConsumer(consumerInfo);
            new Thread(newConsumerThread).start();
        }
    }


    // Attempts to connect to RabbitMQ after a period of time
    private static void reconnect(ConnectionFactory factory, byte connectCount) {
        LOGGER.warn(IMPORTANT, "RabbitMQ Connection failed: trying again after {}s...", connectCount * 12);
        try {
            Thread.sleep(connectCount * 12000);
        }
        catch (InterruptedException mainThreadInterrupted) {
            System.out.println("Main thread was interrupted while sleeping");
        }

	if (connectCount < 5) {
            connectCount++;
        }
        connect(factory, connectCount);
    }




    public static class Message {

        // Publishes a message to RabbitMQ
        public static void publish(String queueName, String message) {
            //Defines message properties
            AMQP.BasicProperties msgProps = new AMQP.BasicProperties().builder()
                    .deliveryMode(2)
                    .appId("sandcastle")
                    .build();

            try {
                channel.queueDeclarePassive(queueName);
                // Message body must be a byte array
                channel.basicPublish("", queueName, msgProps, message.getBytes());
                LOGGER.info("Message published to '{}'", queueName);
            }
            // Catches exceptions when publishing the message
            catch (IOException publishException) {
                System.out.println(publishException.getMessage());
            }
        }


        public static void consume(String queueName, String consumerName) {
            // Executes when a message is consumed
            DeliverCallback deliverCallback = (consumerTag, message) -> {
		Thread.currentThread().setName("Message Consumer");
                LOGGER.info("Message #{} received from '{}'", message.getEnvelope().getDeliveryTag(), queueName);

//                System.out.println("Thread: " + Thread.currentThread().getName() + " | State: " + Thread.currentThread().getState());
//                StackTraceElement[] ste = Thread.currentThread().getStackTrace();
//                for (StackTraceElement stacktrace : ste) {
//                    System.out.println(stacktrace);
//                }
//                System.out.println();

		new Thread(() -> {
		    switch (queueName) {
			case "File Info":
			    ThreadContext.put("msgNo", String.valueOf(message.getEnvelope().getDeliveryTag()));
			    ThreadContext.put("queueName", queueName);
			    ConsumerFunctions.fileChecksumVerification(message, 0);
			    break;
			case "Analysis Report":
			    ThreadContext.put("msgNo", String.valueOf(message.getEnvelope().getDeliveryTag()));
			    ThreadContext.put("queueName", queueName);
			    ConsumerFunctions.analysisReportTransferral(message);
			    break;
		    }
		}).start();
            };

            // Executes when the consumer is removed
            CancelCallback cancelCallback = (consumerTag) -> {
                LOGGER.error(IMPORTANT, "Consumer '{}' was removed from '{}'", consumerTag, queueName);
            };

            // Executes when the chanel or connection is shutdown
            ConsumerShutdownSignalCallback shutdownCallback = ((consumerTag, shutdownSignal) -> {
                LOGGER.warn(IMPORTANT, "'{}' lost connection to RabbitMQ", consumerTag);
            });

            // Begins message consumption
            try {
                channel.basicConsume(queueName, false, consumerName, deliverCallback, cancelCallback, shutdownCallback);
            }
            catch (IOException consumeException) {
                System.out.println(consumeException.getMessage());
            }
        }


        public static String fileInfo(String zipFileName, String zipFileChecksum, String zipFilePass, String encodedFileName, String encodedFileChecksum, String environment) {
            JSONObject message = new JSONObject();
            try {
                //String zipChecksum = ConsumerFunctions.generateFileChecksum(encodedName);

		message.put("zipFileName", zipFileName);
		message.put("zipFileChecksum", zipFileChecksum);;
                message.put("zipFilePass", zipFilePass);
                message.put("encodedFileName", encodedFileName);
                message.put("encodedFileChecksum", encodedFileChecksum);
                message.put("environment", environment);
            }
            catch (Exception ex) {
                System.out.println(ex);
            }

            return message.toString();
        }


	public static String analysisReport(String ip, String fileName) {
	    JSONObject message = new JSONObject();
	    message.put("requester", ip);
	    message.put("fileName", fileName);
	    return message.toString();
	}




        private static class ConsumerFunctions {

            private static String generateFileChecksum(String fileName) throws FileNotFoundException {
                // StringBuffer is thread safe; StringBuilder is not
		StringBuffer fileChecksum = new StringBuffer();
		try {
		    // Provides a way to read the file
		    FileInputStream fileInputStream = new FileInputStream("C:/Users/Public/Downloads/" + fileName);
		    // Reads and copies the file contents into a byte array
		    byte[] fileBytes = fileInputStream.readAllBytes();
		    fileInputStream.close();

		    // Provides a way to obtain a hash value
		    MessageDigest md = MessageDigest.getInstance("SHA1");
		    // Declares the file byte array to have a hash value generated
		    md.update(fileBytes);
		    // Generates the file checksum in a byte array
		    byte[] fileChecksumBytes = md.digest();
		    // Converts the byte array into a HexString format
		    for (int i=0; i < fileChecksumBytes.length; i++) {
			fileChecksum.append(Integer.toHexString(0xFF & fileChecksumBytes[i]));
		    }
		}
		catch (NoSuchAlgorithmException badAlgorithm) {
		    System.out.println(badAlgorithm);
		}
		catch (IOException ioException) {
		    System.out.println(ioException);
		}

                return fileChecksum.toString();
            }


            private static void fileChecksumVerification(Delivery message, int noFileCount) {
		// Converts the byte array back to a String
		String messageContent = new String(message.getBody());
		// Converts the String into a JSON Object
		JSONObject jsonObject = new JSONObject(messageContent);
		String fileName = jsonObject.getString("encodedName");

                LOGGER.info("({}, Msg #{}) Verifying checksum of '{}'...", ThreadContext.get("queueName"), ThreadContext.get("msgNo"), fileName);
                try {
                    String zipChecksum = generateFileChecksum(fileName);
		    System.out.println(zipChecksum);

                    if (zipChecksum.equals(jsonObject.getString("zipChecksum"))) {
                        LOGGER.info("({}, Msg #{}) Integrity of {} ascertained", ThreadContext.get("queueName"), ThreadContext.get("msgNo"), fileName);

			// EMULATES TRANSFERRAL OF FILE TO ANALYSIS VM
			TLS.JavaSocket.pendingDeletion.add(fileName);
                    }
                    else {
                        LOGGER.warn(IMPORTANT, "({}, Msg #{}) Integrity of {} compromised", ThreadContext.get("queueName"), ThreadContext.get("msgNo"), fileName);
                        // Code to update DB with error
                    }

		    channel.basicAck(message.getEnvelope().getDeliveryTag(), false);
		    LOGGER.info("Acked Message #{}", ThreadContext.get("msgNo"));
                }
                catch (FileNotFoundException noFile) {
                    noFileCount++;
                    if (noFileCount <= 3) {
                        try {
                            LOGGER.warn("({}, Msg #{}) Waiting {}s for '{}' to be transferred...", ThreadContext.get("queueName"), ThreadContext.get("msgNo"), (30 +  ((noFileCount - 1) * 10)), fileName);
                            Thread.sleep(30000 +  ((noFileCount - 1) * 10000));
                            fileChecksumVerification(message, noFileCount);
                        }
                        catch (InterruptedException threadInterruptedException) {
                            System.out.println("[" + Thread.currentThread().getName() + "] Interrupted while sleeping");
                        }
                    }
                    else {
			LOGGER.warn("'{}' not found. Nacking message #", fileName, ThreadContext.get("msgNo"));
			try {
			    channel.basicNack(message.getEnvelope().getDeliveryTag(), false, false);
			}
			catch (IOException ioException) {
			    System.out.println(ioException);
			}
                    }
                }
		catch (IOException ioException) {
		    System.out.println(ioException);
		}
            }


	    private static void analysisReportTransferral(Delivery message) {
		// Converts the byte array back to a String
		String messageContent = new String(message.getBody());
		// Converts the String into a JSON Object
		JSONObject jsonObject = new JSONObject(messageContent);
		String ip = jsonObject.getString("requester");
		String fileName = jsonObject.getString("fileName");

		LOGGER.info("({}, Msg #{}) Transferring analysis report for '{}'", ThreadContext.get("queueName"), ThreadContext.get("msgNo"), fileName);

		TLS.JavaSocket.fileTransferQueues.get(ip).add(fileName);

		try {
		    channel.basicAck(message.getEnvelope().getDeliveryTag(), false);
		}
		catch (IOException ioException) {
		    System.out.println(ioException);
		}
		LOGGER.info("Acked Message #{}", ThreadContext.get("msgNo"));
	    }
        }
    }
}
