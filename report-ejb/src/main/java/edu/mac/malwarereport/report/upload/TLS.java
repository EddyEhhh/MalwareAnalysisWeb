
package edu.mac.malwarereport.report.upload;

import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.CertificateException;
import java.util.*;
import java.util.concurrent.*;
import javax.net.ssl.*;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.Marker;
import org.apache.logging.log4j.MarkerManager;
import org.javatuples.*;



class TLS {

    //File log4j2ConfigFile = new File("D:/MP Stuff/MP/MLAB Major Project G22/report-ejb/src/main/resources/META-INF/log4j2.xml");
    
    
    // Declares a logger object
    private static Logger LOGGER = LogManager.getLogger(TLS.class);
    private static Marker IMPORTANT = MarkerManager.getMarker("IMPORTANT");


    public static KeyManagerFactory keyStore(String keyStorePath) {
        KeyManagerFactory keyMF = null;
        try {
            char[] keyStorePass = "password".toCharArray();
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream(keyStorePath), keyStorePass);

            keyMF = KeyManagerFactory.getInstance("SunX509");
            keyMF.init(keyStore, keyStorePass);
        }
        catch (FileNotFoundException noKeyStoreFile) {
            LOGGER.error(IMPORTANT, "No Java KeyStore file found at '" + keyStorePath + "'");
        }
	catch (NoSuchAlgorithmException badAlgorithm) {
	    LOGGER.error(IMPORTANT, "Invalid KeyManagerFactory algorithm requested");
	}
	catch (UnrecoverableKeyException unrecoverableKey) {
	    LOGGER.error(IMPORTANT, "Unable to retrieve Private Key from " + keyStorePath);
	}
	catch (CertificateException certificateException) {
	}
	catch (KeyStoreException keyStoreException) {
	}
	catch (IOException iOException) {
	}
        return keyMF;
    }


    public static TrustManagerFactory trustStore(String trustStorePath) {
        TrustManagerFactory trustMF = null;
        try {
            char[] trustStorePass = "password".toCharArray();
            KeyStore trustStore = KeyStore.getInstance("PKCS12");
            trustStore.load(new FileInputStream(trustStorePath), trustStorePass);

            trustMF = TrustManagerFactory.getInstance("SunX509");
            trustMF.init(trustStore);
        }
        catch (FileNotFoundException noKeyStoreFile) {
            LOGGER.error(IMPORTANT, "No Java KeyStore file found at '" + trustStorePath + "'");
        }
	catch (NoSuchAlgorithmException badAlgorithm) {
	    LOGGER.error(IMPORTANT, "Invalid KeyManagerFactory algorithm requested");
	}
	catch (CertificateException certificateException) {

	}
	catch (KeyStoreException keyStoreException) {

	}
	catch (IOException iOException) {

	}
        return trustMF;
    }


    public static SSLContext sslContext(KeyManagerFactory keyMF, TrustManagerFactory trustMF) {
        SSLContext sslContext = null;
        try {
            sslContext = SSLContext.getInstance("TLSv1.2");
            sslContext.init(keyMF.getKeyManagers(), trustMF.getTrustManagers(), null);
        }
	catch (NoSuchAlgorithmException badAlgorithm) {
	    LOGGER.error(IMPORTANT, "Invalid KeyManagerFactory algorithm requested");
	}
	catch (KeyManagementException keyManagementException) {
	}
        return sslContext;
    }




    public static class JavaSocket {

	public static class SocketInfo {
	    String ipAddress;
	    int firstPort;
	    int lastPort;
	    String type;
	    String usage;

	    SocketInfo(String ipAddress, int firstPort, int lastPort, String type, String usage) {
		this.ipAddress = ipAddress;
		this.firstPort = firstPort;
		this.lastPort = lastPort;
		this.type = type;
		this.usage = usage;
	    }

	    @Override
	    public String toString() {
		return "Setting up " + type + " sockets for " + ipAddress;
	    }

	}

	private static String keyStorePath;
	private static String trustStorePath;

	// Declares an unbounded ArrayList containing SocketInfo objects
	public static ArrayList<SocketInfo> socketList = new ArrayList<SocketInfo>();
	// Declares an unbounded LinkedBlockingQueue containing Pair objects (ip, port)
	private static final LinkedBlockingQueue<Pair<String, Integer>> availableClientSockets = new LinkedBlockingQueue<Pair<String, Integer>>();
	// Declares an unbounded LinkedBlockingQueue containing Pair objects (ip, port)
	private static final LinkedBlockingQueue<Pair<String, Integer>> availableServerSockets = new LinkedBlockingQueue<Pair<String, Integer>>();
	// Declares an unbounded ConcurrentHashMap containing String keys and a LinkedBlockingQueue values (ip, LinkedBlockingQueue<file name>)
	public static final ConcurrentHashMap<String, LinkedBlockingQueue> fileTransferQueues = new ConcurrentHashMap<String, LinkedBlockingQueue>();

	// Declares an unbounded LinkedBlockingQueue containing Strings (file names)
	public static LinkedBlockingQueue<String> pendingDeletion = new LinkedBlockingQueue<String>();



	public static void connectionSetup(String keyStorePath, String trustStorePath) {
	    JavaSocket.keyStorePath = keyStorePath;
	    JavaSocket.trustStorePath = trustStorePath;


	    for (SocketInfo socketInfo : socketList) {
		System.out.println(socketInfo);
		try {
		    switch (socketInfo.type) {
			case "client":
			    // Repo VM will have client sockets connections to different Web VMs for analysis report transferral
			    // A client socket connected to the requesting Web VM will need to be used to transfer the analysis report
			    // Therefore all client socket connections to a specific Web VM require their own pendingTransfer queue

			    // Declares an unbounded LinkedBlockingQueue containing Strings (file names) and adds it to the ConcurrentHashMap
			    // LinkedBlockingQueue can be retrieved based on the IP Address the client sockets are connected to
			    fileTransferQueues.put(socketInfo.ipAddress, new LinkedBlockingQueue<Pair<String, String>>());

			    for (int portNum = socketInfo.firstPort; portNum <= socketInfo.lastPort; portNum++) {
				availableClientSockets.add(new Pair<>(socketInfo.ipAddress, portNum));
			    }

			    // Creates a new thread for each socket connection to run in
			    for (int i = 0; i < Math.floorDiv((socketInfo.lastPort - socketInfo.firstPort) + 1, 2); i++) {
				Pair<String, Integer> socket = availableClientSockets.take();
				String ipAddress = socket.getValue0();
				int portNum = socket.getValue1();

				new Thread(() -> {
				    clientConnection(ipAddress, portNum, 0, socketInfo.usage);
				}).start();
			    }
			    break;
			case "server":
			    for (int portNum = socketInfo.firstPort; portNum <= socketInfo.lastPort; portNum++) {
				availableServerSockets.add(new Pair<>(socketInfo.ipAddress, portNum));
			    }

			    // Creates a new thread for each server socket connection to run in
			    for (int i = 1; i <= (socketInfo.lastPort - socketInfo.firstPort) + 1; i++) {
				Pair<String, Integer> socket = availableServerSockets.take();
				String ipAddress = socket.getValue0();
				int portNum = socket.getValue1();

				// Creates a new ServerSocket bound to the port
				SSLServerSocket serverSocket = serverSocketSetup(ipAddress, portNum);
				new Thread(() -> {
				    serverConnection(serverSocket, ipAddress, portNum, socketInfo.usage);
				}).start();
			    }
			    break;
		    }
		}
		catch (InterruptedException threadInterrupted) {
		    LOGGER.error("Thread was interrupted " + threadInterrupted);
		}
	    }


	    System.out.println("Creating File Delete Thread");
	    // Creates a thread that deletes files
	    new Thread(() -> {
		Thread.currentThread().setName("File Deleter");
		System.out.println("Created File Delete Thread");
		while (true) {
		    try {
			FileTransferral.delete(pendingDeletion.take());
                        
		    }
		    catch (InterruptedException threadInterrupted) {
			LOGGER.error("Thread was interrupted " + threadInterrupted);
		    }
		}
	    }).start();
	}


	// Connects to the server socket
        private static void clientConnection(String ipAddress, int portNum, int reconnectionCount, String usage) {
	    try {
		SSLSocketFactory sf = TLS.sslContext(keyStore(keyStorePath), trustStore(trustStorePath)).getSocketFactory();
		SSLSocket clientSSLSocket = (SSLSocket)sf.createSocket(ipAddress, portNum);
		boolean connectionAlive = true;
		Thread.currentThread().setName(clientSSLSocket.getInetAddress().toString() + ":" + clientSSLSocket.getLocalPort());
		LOGGER.info("Connected to {}", clientSSLSocket.getRemoteSocketAddress());

		// Specifies where data is being written to
		DataOutputStream outputStream = new DataOutputStream(clientSSLSocket.getOutputStream());

		// Retrieves the LinkedBlockingQueue containing the names of files to be transferred to the IP Address
		LinkedBlockingQueue<Pair<String, String>> pendingTransfer = fileTransferQueues.get(ipAddress);

		// Persists socket connection with client as long as they are alive
		while (connectionAlive) {
                    Pair<String, String> pair = pendingTransfer.take();
                    String fileName = pair.getValue0();
                    String fileInfoMessage = pair.getValue1();
		    
                    System.out.println("Sending " + fileName + " to Repo VM...");
                    connectionAlive = FileTransferral.send(outputStream, fileName, fileInfoMessage, pendingTransfer, usage);
                    
                    System.out.println(fileName +  " sent to Repo VM");
                }
		// If while loop is exited, the socket connection has died

		LOGGER.warn(IMPORTANT, "Reconnecting to {}:{} after 10s...", ipAddress, portNum);
		clientRecovery(ipAddress, portNum, reconnectionCount, usage);
	    }
	    catch (ConnectException connectException) {
		LOGGER.warn(IMPORTANT, "Connection to {}:{} failed. Trying again after 10s...", ipAddress, portNum);
		clientRecovery(ipAddress, portNum, reconnectionCount, usage);
	    }
	    catch (InterruptedException threadInterrupted) {
		LOGGER.error("Interrupted while taking from 'pendingTransfer'");
	    }
	    catch (IOException ioException) {
	    }
        }


	private static void clientRecovery(String ipAddress, int portNum, int reconnectCount, String usage) {
	    reconnectCount++;
	    try {
		switch (reconnectCount) {
		    case 3:
			// Returns the socket used back into the queue for future usage
			availableClientSockets.add(new Pair<>(ipAddress, portNum));
			// Takes a socket and establishes a new connection with it
			Pair<String, Integer> socketInfo = availableClientSockets.take();
			ipAddress = socketInfo.getValue0();
			portNum = socketInfo.getValue1();

			clientConnection(ipAddress, portNum, 0, usage);
			break;
		    default:
			Thread.sleep(10000);
			clientConnection(ipAddress, portNum, reconnectCount, usage);
		}
	    }
	    catch (InterruptedException threadInterrupted) {
	    }
        }


	// When ServerSockets accept() an incoming client connection, they create NEW sockets based on it
	// This means the client socket is not connected to the ServerSocket but to the NEW socket created by it
	// So when the client dies, only the NEW socket diees; The ServerSocket is still listening on the port bound to it
        private static SSLServerSocket serverSocketSetup(String ipAddress, int portNum) {
	    SSLServerSocket serverSocket = null;
	    try {
		SSLServerSocketFactory serversf = TLS.sslContext(keyStore(keyStorePath), trustStore(trustStorePath)).getServerSocketFactory();
		serverSocket = (SSLServerSocket)serversf.createServerSocket();
		serverSocket.setReuseAddress(true);
		serverSocket.setNeedClientAuth(true);
		serverSocket.bind(new InetSocketAddress(portNum));

		Thread.currentThread().setName(ipAddress + ":" + portNum);
	    }
	    catch (SocketException socketException) {
		System.out.println("[" + Thread.currentThread().getName() + "] " + socketException);
		System.out.println("Caught in serverSocketSetup");
	    }
	    catch (IOException ioException) {
		System.out.println("[" + Thread.currentThread().getName() + "] " + ioException);
		System.out.println("Caught in serverSocketSetup");
	    }
	    return serverSocket;
        }


	private static void serverConnection(SSLServerSocket serverSocket, String ipAddress, int portNum, String usage) {
	    try {
		Thread.currentThread().setName(ipAddress + ":" + portNum);

		// Listens for any new incoming connections on ServerSocket
		LOGGER.info("Listening for new incoming connections...");
		// Establishes only one socket connection
		SSLSocket serverSSLSocket = (SSLSocket)serverSocket.accept();
		// accept() blocks until a new connection is established

		// After a new connection is established, the ServerSocket stops listening for new connections
		Thread.currentThread().setName(ipAddress + ":" + portNum);
		LOGGER.info("Accepted connection from {}:{}", serverSSLSocket.getInetAddress().toString(), serverSSLSocket.getPort());

		// Specifies where data is being read from
		DataInputStream inputStream = new DataInputStream(serverSSLSocket.getInputStream());
		// Persists socket connection with client as long as they are alive by continuously reading the DataInputStream
		boolean connectionAlive = true;
		while (connectionAlive) {
		    connectionAlive = FileTransferral.receive(serverSSLSocket, inputStream, usage);
		}
		// If while loop is exited, the socket connection has died

		// Makes ServerSocket listen and accept another incoming connection
		serverRecovery(serverSocket, ipAddress, portNum, usage);
	    }
	    catch (IOException ioException) {}
	}


	private static void serverRecovery(SSLServerSocket serverSocket, String ipAddress, int portNum, String usage) {
	    serverConnection(serverSocket, ipAddress, portNum, usage);
        }




	public static class FileTransferral {

	    private static boolean send(DataOutputStream outputStream, String fileName, String fileInfoMessage, LinkedBlockingQueue pendingTransfer, String usage) {
		try {
		    // Specifies the file to transfer
		    File fileToTransfer = new File("C:/Users/Public/Downloads/" + fileName);
		    // Provides a way to read the file
		    FileInputStream fileInputStream = new FileInputStream(fileToTransfer);
		    // Writes the file name into a byte array
		    byte[] fileNameBytes = fileName.getBytes();
		    // Writes the file into a byte array
		    byte[] fileBytes = fileInputStream.readAllBytes();
                    // Stops accessing the file
		    fileInputStream.close();
                    
		    // Sends the file name byte length
		    outputStream.writeInt(fileNameBytes.length);
		    // Sends the file name bytes
		    outputStream.write(fileNameBytes);

		    // Sends the file byte length
		    outputStream.writeInt(fileBytes.length);
		    // Sends the file bytes
		    outputStream.write(fileBytes);
		    LOGGER.info("'{}' sent", fileName);
                    
                    // Queues file for deletion
                    System.out.println("Proceeding to delete file...");
		    pendingDeletion.add(fileName);

		    switch (usage) {
			case "artefact":
			    RabbitMQ.Message.publish("File Info", fileInfoMessage);
			    break;
		    }

		}
//		catch (SSLPeerUnverifiedException badPeerException) {
//		    System.out.println(badPeerException);
//		    System.out.println("Caught in SSLPeerUnverifiedException");
//		}
//		catch (SSLKeyException badKeyException) {
//		    System.out.println(badKeyException);
//		    System.out.println("Caught in SSLKeyException");
//		}
//		catch (SSLProtocolException badProtocolException) {
//		    System.out.println(badProtocolException);
//		    System.out.println("Caught in SSLProtocolException");
//		}
		catch (SSLHandshakeException handshakeException) {
		    if (handshakeException.getMessage().contains("No trusted certificate found")) {
			LOGGER.warn(IMPORTANT, "Untrusted certificate presented by server");
		    }
		    else {
			System.out.println("[" + Thread.currentThread().getName() + "] " + handshakeException);
		    }
		    pendingTransfer.add(fileName);
		    return false;
		}
		catch (SSLException sslException) {
		    if (sslException.getMessage().contains("readHandshakeRecord")) {
			    LOGGER.warn(IMPORTANT, "Connection rejected by server");
		    }
		    else if (sslException.getMessage().contains("kickstart handshaking")) {
			    LOGGER.warn(IMPORTANT, "Server disconnected");
		    }
		    else {
			System.out.println("[" + Thread.currentThread().getName() + "] " + sslException);
		    }
		    pendingTransfer.add(fileName);
		    return false;
		}
		catch (FileNotFoundException noFile) {
		    LOGGER.warn("File not found");
		}
		catch (IOException ioException) {
		    if (ioException.getMessage().contains("socket write error")) {
			System.out.println("Server disconnected");
		    }
		    else {
			System.out.println("[" + Thread.currentThread().getName() + "] " + ioException);
			System.out.println("Caught in IOException in send()");
		    }
		    pendingTransfer.add(fileName);
		    return false;
		}

		return true;
	    }


	    public static boolean receive(SSLSocket serverSSLSocket, DataInputStream inputStream, String usage) {
		String remoteSocket = serverSSLSocket.getRemoteSocketAddress().toString();
		try {
		    // Gets the legnth of the file name in bytes
		    int fileNameLength = inputStream.readInt();
		    if (fileNameLength > 0) {
			// Creates a byte array the size of the file name in bytes
			byte[] fileNameBytes = new byte[fileNameLength];
			// Stores the file name bytes in the byte array
			inputStream.readFully(fileNameBytes, 0, fileNameBytes.length);
			String fileName = new String(fileNameBytes);

			// Creates a byte array the size of the file content in bytes
			byte[] fileContentBytes = new byte[inputStream.readInt()];
			// Stores the file content bytes in the byte array
			inputStream.readFully(fileContentBytes, 0, fileContentBytes.length);
                        
                        System.out.println("New file received");

			switch (usage) {
			    case "artefact":
                                System.out.println("Creating new artefact!");
				createFile(fileName, fileContentBytes);
				break;
                            case "report":
                                System.out.println("Creating new report!");
                                createFile(fileName, fileContentBytes);
                                break;
			}
		    }
		}
//		catch (SSLPeerUnverifiedException badPeerException) {
//		    System.out.println(badPeerException);
//		    System.out.println("Caught in SSLPeerUnverifiedException");
//		}
//		catch (SSLKeyException badKeyException) {
//		    System.out.println(badKeyException);
//		    System.out.println("Caught in SSLKeyException");
//		}
//		catch (SSLProtocolException badProtocolException) {
//		    System.out.println(badProtocolException);
//		    System.out.println("Caught in SSLProtocolException");
//		}
		catch (SSLHandshakeException handshakeException) {
		    if (handshakeException.getMessage().contains("Empty server certificate chain")) {
			LOGGER.warn("Untrusted certificate from " + remoteSocket);
		    }
		    else if (handshakeException.getMessage().contains("Received fatal alert: certificate_unknown")) {
			LOGGER.warn("Connection rejected by " + remoteSocket);
		    }
		    else {
		    }
		    return false;
		}
		catch (SSLException sslException) {
		    if (sslException.getMessage().contains("Connection reset")) {
			LOGGER.warn(remoteSocket + " disconnected");
		    }
		    else {
		    }
		    return false;
		}
		catch (IOException ioException) {

		}

		return true;
	    }


	    private static void createFile(String fileName, byte[] fileContentBytes) {
		try {
		    // Put this into a new funtion that will take in the file byte array as a parameter and return a boolean instead of THIS function
		    // This new function will be the one ran in the while loop
		    // THIS function here will return a byte array instead of a boolean
                    
                    System.out.println("Creating new file \'" + fileName + "\'");
                    
		    // Specifies the new file to create
		    File fileToReceive = new File("D:\\MLCG\\NetBeansProjects\\Malware Analysis Web\\malware-report-web\\src\\main\\resources\\files\\" + fileName);
                    System.out.print("A1");
		    // Provides a way to write to the new file
		    FileOutputStream fileOutputStream = new FileOutputStream(fileToReceive);
		    // Writes the file content into the new file
                    System.out.print("A1");
		    fileOutputStream.write(fileContentBytes);
                    System.out.print("A1");
		    fileOutputStream.close();
                    
                    System.out.println("Successfully created new file");

		    LOGGER.info("Successfully created file '{}'", fileName);
		}
		catch (IOException ex) {

		}
	    }


	    private static void delete(String fileName) {
		// Specifies the file to delete
		File fileToDelete = new File("C:/Users/Public/Downloads/" + fileName);
		if (fileToDelete.delete()) {
                    System.out.println("Deleted " + fileName);
		    LOGGER.info("Deleted '{}'", fileName);
		}
		else {
                    System.out.println("Failed to delete " + fileName);
		    LOGGER.warn("Failed to delete '{}'", fileName);
		}
	    }
	}
    }
}