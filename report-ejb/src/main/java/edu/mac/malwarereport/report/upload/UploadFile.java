/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package edu.mac.malwarereport.report.upload;

import edu.mac.malwarereport.account.authenticate.Authenticate;
import edu.mac.malwarereport.account.ownershipassignment.mapper.AccountOrganisationMapper;
import edu.mac.malwarereport.report.data.SampleFacade;
import edu.mac.malwarereport.report.entity.Report;
import edu.mac.malwarereport.report.entity.ReportValue;
import edu.mac.malwarereport.report.entity.Sample;
import edu.mac.malwarereport.report.ownershipassignment.mapper.ReportOrganisationMapper;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Date;
import java.util.List;
import net.lingala.zip4j.ZipFile;
import net.lingala.zip4j.model.ZipParameters;
import net.lingala.zip4j.model.enums.CompressionLevel;
import net.lingala.zip4j.model.enums.EncryptionMethod;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.tika.Tika;

import org.apache.commons.io.FilenameUtils;
import org.javatuples.Pair;

/**
 *
 * @author tohyu
 */
@Named("uploadFile")
@Stateless
public class UploadFile {

    @Inject
    private SampleFacade sampleFacade;
    
    @Inject
    private Authenticate authenticate;
    
    @Inject
    private ReportOrganisationMapper reportOrganisationMapper;
    
    @Inject
    private AccountOrganisationMapper accountOrganisationMapper;
    
    private boolean notification;
    private String currentDate = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss").format(new Date());

    public boolean upload(byte[] bytes, String uploadFilePath, String encodedFileName, String environment, String fileName) throws IOException {
        //make sure that the file and environment are chosen by the user
        if (bytes != null && environment != null) {
            Path filePath = Paths.get(uploadFilePath + encodedFileName);
            //upload file process
            File uploadFile = uploadFile(encodedFileName, bytes);
            //check whether the filename and extension are acceptable
            if (checkLengthFileName(fileName) && checkFileSize(filePath) && validateFileTypeByTikaA(uploadFile)) {
                //hashvalue of the uploaded file
                String encodedFileCheckSum = hashvalueUploadedFile(encodedFileName, uploadFile);
                //make sure that the uploaded file is read only
                uploadFile.setReadOnly();
                //zip filename
                String zipFileName = zipFileName(encodedFileName);
                //random generated password
                String zipFilePassword = randomGenPasswd();
                //zip file 
                ZipFile zipfile = createZipFile(zipFileName, zipFilePassword, uploadFile);
                 //do checksumSHA256 for the zip file
                String zipFileCheckSum = hashvalueZippedFile(zipFileName);
                zipfile.close();
                uploadFile.delete();
                zipFileName = zipFileName + ".zip";
                Report report = new Report("null");
                ReportValue reportValue = new ReportValue(fileName);
                Sample sample = new Sample(environment, "In-Queue", zipFileName, reportValue, report);
                sampleFacade.create(sample);
                sample.getReport().setFilePath("/resources/files/Sandcastle Report - " + sample.getReportValue().getSampleName() + " (" + sample.getSuuid() + ").pdf");
                sampleFacade.edit(sample);
                Long accountId = authenticate.getCurrentAccount().getId();
                reportOrganisationMapper.createMapping(accountOrganisationMapper.getOrganisationId(accountId)
                        , sample.getId());
                
                
//                    Report report = new Report();                  

                String fileInfoMessage = RabbitMQ.Message.fileInfo(zipFileName, zipFileCheckSum, zipFilePassword, encodedFileName, encodedFileCheckSum, environment);

                //Sample sample = 
                //file transferal
                System.out.println("ADDING '" + zipFileName + "' to File Transferral Queue");
                TLS.JavaSocket.fileTransferQueues.get("10.242.248.1").add(new Pair<>(zipFileName, fileInfoMessage));
                System.out.println("ADDED '" + zipFileName + "' to File Transferral Queue");

                //delete file                    
//                    File deleteZipFile = zipfile.getFile();
//                    deleteZipFile.delete();
                return true;
            } else {
                //delete file
                //pendingDeletion.add(uploadFile.toString());
                uploadFile.delete();
                System.out.print("criteria not met");
                return false;
            }
        } else {
            System.out.print("no file / environment selected");
            return false;
        }
    }

    public String getFileName(String fileName) {
        return FilenameUtils.getBaseName(fileName);
    }

    public String encodeString(String fileName) {

        String encodedFileName = Base64.getEncoder().encodeToString(fileName.getBytes());
        return encodedFileName;
    }

    private boolean checkLengthFileName(String fileName) {
        if (fileName.length() > 0 && fileName.length() <= 200) {
            return true;
        } else {
            return false;
        }
    }

    private static boolean validateFileTypeByTikaA(File file) {

        final Tika tika = new Tika();
        try {
            String fileType = tika.detect(file);

            List<String> fileTypeAccept = new ArrayList<>();
            fileTypeAccept.add("application/x-msdownload");
            fileTypeAccept.add("application/x-sharedlib");
            fileTypeAccept.add("application/x-object");
            fileTypeAccept.add("application/x-executable");
            fileTypeAccept.add("application/x-coredump");
            fileTypeAccept.add("application/pdf");
            fileTypeAccept.add("application/msword");
            fileTypeAccept.add("application/sldworks");

            String imageAcceptRegex = "image/(.*)";
            String textAcceptRegex = "text/(.*)";
            String audioAcceptRegex = "audio/(.*)";
            String videoAcceptRegex = "video/(.*)";
            String microsoftTikaAcceptRegex = "application/x-tika(.*)";
            String mircosoftVndAcceptRegex = "application/vnd.ms(.*)";
            String microsoftAcceptRegex = "application/x-ms(.*)";

            if (fileType.matches(imageAcceptRegex) || fileType.matches(textAcceptRegex) || fileType.matches(audioAcceptRegex)
                    || fileType.matches(videoAcceptRegex) || fileType.matches(microsoftAcceptRegex) || fileType.matches(microsoftTikaAcceptRegex)
                    || fileType.matches(mircosoftVndAcceptRegex) || fileTypeAccept.contains(fileType)) {
                System.out.print("this is the file type " + fileType);
                return true;
            } else {
                System.out.print("this is the file type " + fileType);
                return false;

            }
        } catch (IOException e) {
            System.out.println("*** getFileTypeByTika - Error while detecting mime type from InputStream ***");
            System.out.println("*** getFileTypeByTika - Error message: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    private boolean checkFileSize(Path filePath) throws IOException {
        long bytes = Files.size(filePath);
        if (bytes > 0 && bytes < 16000000) {
            return true;
        } else {
            return false;
        }
    }

    private File uploadFile(String encodedFileName, byte[] bytes) throws IOException {
        //for the uploaded file
        System.out.print("B0");
        InputStream fileInputStream = new ByteArrayInputStream(bytes);
        System.out.print("B1");
        File file = new File("C:/Users/Public/Downloads/" + encodedFileName);
        System.out.print("B2");
        OutputStream outputStream = new FileOutputStream(file);
        System.out.print("B3");
        //get the file stuff byte by byte
        int read = 0;
        byte[] byteArray = new byte[1024];
        System.out.print("B4");
        while ((read = fileInputStream.read(byteArray)) != -1) {
            outputStream.write(byteArray, 0, read);
        }
        System.out.print("B5");
        fileInputStream.close();
        System.out.print("B6");
        outputStream.close();
        System.out.print("B7");
        return file;
    }

    private String hashvalueUploadedFile(String unzipFileName, File newfile) throws IOException {
        InputStream input = new FileInputStream(newfile);
        String checksumSHA256 = DigestUtils.sha256Hex(input);
        input.close();
        System.out.println("Uploaded file: " + unzipFileName + " checksumSHA256 : " + checksumSHA256);
        return checksumSHA256;
    }

    private String hashvalueZippedFile(String zipFileName) throws IOException {
        InputStream input = new FileInputStream("C:/Users/Public/Downloads/" + zipFileName + ".zip");
        String checksumSHA256 = DigestUtils.sha256Hex(input);
        input.close();
        System.out.println("Zipped File: " + zipFileName + " checksumSHA256 : " + checksumSHA256);
        return checksumSHA256;
    }

    private String zipFileName(String unzipFileNameWithoutExt) {
        //name the zip file
        String zipFileName = unzipFileNameWithoutExt + "_" + getCurrentDate();
        return zipFileName;
    }

    private String randomGenPasswd() {
        //randomly generate password from the zip file
        char[] possibleCharacters = (new String("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789").toCharArray());
        String randomStr = RandomStringUtils.random(10, 0, possibleCharacters.length - 1, false, false, possibleCharacters, new SecureRandom());
        System.out.println("this is random generator password " + randomStr);
        return randomStr;
    }

    private ZipFile createZipFile(String zipFileName, String randomStr, File newfile) throws IOException {
        //add the parameters which define different properties
        ZipParameters zipParameters = new ZipParameters();
        zipParameters.setEncryptFiles(true); //set the encryption flag to be true
        zipParameters.setCompressionLevel(CompressionLevel.HIGHER); //set the compression level
        zipParameters.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); //set the encryption method

        //add the name of the zip file (with the directory),  add the generated password
        ZipFile zipFile = new ZipFile("C:/Users/Public/Downloads/" + zipFileName + ".zip", randomStr.toCharArray());
        zipFile.addFile(newfile, zipParameters);
        zipFile.close();

        return zipFile;
    }

    /**
     * @return the notification
     */
    public boolean isNotification() {
        return notification;
    }

    /**
     * @param notification the notification to set
     */
    public void setNotification(boolean notification) {
        this.notification = notification;
    }

    /**
     * @return the currentDate
     */
    public String getCurrentDate() {
        return currentDate;
    }

    /**
     * @param currentDate the currentDate to set
     */
    public void setCurrentDate(String currentDate) {
        this.currentDate = currentDate;
    }
}
