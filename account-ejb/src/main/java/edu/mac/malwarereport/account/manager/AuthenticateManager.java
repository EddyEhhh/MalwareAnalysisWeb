/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.mac.malwarereport.account.manager;

import edu.mac.malwarereport.account.authenticate.Authenticate;
import edu.mac.malwarereport.account.authenticate.Authenticate2FA;
import edu.mac.malwarereport.account.authenticate.Captcha;

import edu.mac.malwarereport.account.data.AccountFacade;
import edu.mac.malwarereport.account.data.EmailVerificationFacade;
import edu.mac.malwarereport.account.dto.AccountDTO;
import edu.mac.malwarereport.account.dto.EmailVerificationDTO;
import edu.mac.malwarereport.account.entity.Account;
import edu.mac.malwarereport.account.entity.EmailVerification;
import edu.mac.malwarereport.account.entity.LoginAttempt;
import edu.mac.malwarereport.account.outputInfo.AuthenticateStatus;
import edu.mac.malwarereport.account.outputInfo.EmailVerificationStatus;
import edu.mac.malwarereport.account.ownershipassignment.manager.AccountOrganisationManager;
import edu.mac.malwarereport.account.ownershipassignment.mapper.AccountOrganisationMapper;
import edu.mac.malwarereport.account.resource.AccountDetailGenerator;
import edu.mac.malwarereport.account.resource.DateChecker;
import edu.mac.malwarereport.account.resource.SecureTokenGenerator;
import edu.mac.malwarereport.organisation.data.OrganisationFacade;
import edu.mac.malwarereport.organisation.dto.OrganisationDTO;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import java.io.IOException;
import java.util.Date;

/**
 *
 * @author Jaibun Thana
 */
@Stateless
public class AuthenticateManager {

    @Inject
    private AccountFacade accountFacade;

    @Inject
    private EmailVerificationFacade emailVerificationFacade;

    @Inject
    private Authenticate2FA auth2FA;

    @Inject
    private Authenticate auth;

    @Inject
    private AccountDetailGenerator accountDetailGenerator;

    @Inject
    private SecureTokenGenerator secureTokenGenerator;

    @Inject
    private MailerManager mailerManager;

    @Inject
    private AccountManager accountManager;

    @Inject
    private DateChecker dateChecker;
    
    @Inject
    private Captcha captcha;
       
    @Inject
    private OrganisationFacade organisationFacade;
    
    @Inject
    private AccountOrganisationMapper accountOrganisationMapper;

    public AuthenticateStatus tryAuthorise(String email) {
        try{
        if (isVerified(email)) {
            System.out.print("isVerified");
            if (isAuthorised(email)) {
                System.out.print("isAuthorised");
                if (!isDeleted(email)){
                    System.out.print("isNotDelete");
                    return AuthenticateStatus.SUCCESS;
                }else{
                    return AuthenticateStatus.DELETED;
                }
            }else{
                System.out.print("locked");
                return AuthenticateStatus.LOCKOUT;
            }

        }else{
            System.out.print("notVerified");
            return AuthenticateStatus.NOT_VERIFIED;
        }
        }catch (Exception e){
            return AuthenticateStatus.FAILURE;
        }

    }
    
    private boolean isDeleted(String email){
        return accountFacade.getAccount(email).isDelete();
    }

    private boolean isVerified(String email) {
        EmailVerification emailVerification = accountFacade.getAccount(email).getEmailVerification();
        return emailVerification.isVerified();
    }
    
    public boolean isVerifiedCaptcha(String captchaResponse) throws IOException{
        return captcha.verify(captchaResponse);
    }

    private boolean isAuthorised(String email) {
        //Check brute force security
        Account account = accountFacade.findByEmail(email);
        LoginAttempt loginAttempt = account.getLoginAttempt();
        
        //get the account and the user's organisation
        long accountId = account.getId();
        long organisationId = accountOrganisationMapper.getOrganisationId(accountId);
        OrganisationDTO organisationDTO = organisationFacade.find(organisationId).toDTO();

        int lockoutTime = organisationDTO.getSettingDTO().getLockoutTime();
        int maxLoginAttempt = organisationDTO.getSettingDTO().getMaxLoginAttempt();
        
        //check for the timer if it is already 20 minutes
        Date timeout = loginAttempt.getTimestamp();
        //System.out.print(timeout);
        boolean timer = dateChecker.timer(timeout, lockoutTime);
        if (loginAttempt.getNumberOfAttempt() < maxLoginAttempt || timer == true) {
            return true;
        } else {
            return false;
        }
    }

    public EmailVerificationStatus emailVerification(EmailVerificationDTO emailVerificationDTO) {
        String token = emailVerificationDTO.getToken();

        try {
            EmailVerification emailVerification = emailVerificationFacade.emailVerificationByToken(token);
            if (emailVerification.isVerified()) {
                return EmailVerificationStatus.FAILURE;
            }
            Date timeout = emailVerification.getTimestamp();
            if (dateChecker.isWithinTimeout(timeout, 259200)) {
                emailVerification.setVerified(true);
                emailVerificationFacade.edit(emailVerification);
                return EmailVerificationStatus.SUCCESS;
            } else {
                Account account = accountFacade.getAccountByEmailVerification(emailVerification);
                EmailVerification newEmailVerification = accountManager.createEmailVerification();
                account.setEmailVerification(newEmailVerification);
                accountFacade.edit(account);
                emailVerificationFacade.remove(emailVerification);
                mailerManager.emailVerification(account);
                return EmailVerificationStatus.TOKEN_EXPIRE;
            }
        } catch (Exception e) {
            return EmailVerificationStatus.FAILURE;
        }
    }

    public boolean isAuthenticated() {
        return auth.isAuthenticated();
    }

    public boolean isFirstLogin(String email) {
        return auth.isFirstLogin(email);
    }

    public boolean checkInputTOTP(String totp, String email) {
        String secretKey = accountFacade.getAccount(email).getSecretKey2FA();
        String currentTOTP = auth2FA.getTOTPCode(secretKey);
        if (totp.equals(currentTOTP)) {
            auth.firstLogin(email);
            return true;
        } else {
            return false;
        }

    }

    public boolean isCredentialValid(String email, String password) {
        return auth.isCredentialValid(email, password);
    }

    public byte[] getAuthQR(String email, String issuer) throws Exception {
        String secretKey = accountFacade.getAccount(email).getSecretKey2FA();
        return auth2FA.getAuthQR(email, secretKey, issuer);
    }

    public AccountDTO findByEmail(String email) {
        Account account = accountFacade.findByEmail(email);
        return account.toDTO();
    }

}
