/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.mac.malwarereport.account.manager;

import edu.mac.malwarereport.account.authenticate.Authenticate;
import edu.mac.malwarereport.account.authenticate.Authenticate2FA;

import edu.mac.malwarereport.account.data.AccountFacade;
import edu.mac.malwarereport.account.data.PasswordTokenFacade;
import edu.mac.malwarereport.account.dto.AccountDTO;
import edu.mac.malwarereport.account.dto.EmailVerificationDTO;
import edu.mac.malwarereport.account.entity.Account;
import edu.mac.malwarereport.account.entity.EmailVerification;
import edu.mac.malwarereport.account.entity.PasswordToken;
import edu.mac.malwarereport.account.outputInfo.OutcomeStatus;
import edu.mac.malwarereport.account.outputInfo.RegisterStatus;
import edu.mac.malwarereport.account.outputInfo.ResetPasswordStatus;
import edu.mac.malwarereport.account.ownershipassignment.manager.AccountOrganisationManager;
import edu.mac.malwarereport.account.ownershipassignment.mapper.AccountOrganisationMapper;
import edu.mac.malwarereport.account.resource.AccountDetailGenerator;
import edu.mac.malwarereport.account.resource.DateChecker;
import edu.mac.malwarereport.account.resource.SecureTokenGenerator;
import edu.mac.malwarereport.account.subjectassignment.manager.SubjectRoleManager;
import edu.mac.malwarereport.role.dto.RoleDTO;
import edu.mac.malwarereport.subjectassignment.outputinfo.MappingStatus;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import java.time.chrono.Era;
import java.util.Date;
import java.util.List;

/**
 *
 * @author Jaibun Thana
 */
@Stateless
public class AccountManager {

    @Inject
    private AccountFacade accountFacade;

    @Inject
    private PasswordTokenFacade passwordTokenFacade;

    @Inject
    private Authenticate2FA auth2FA;

    @Inject
    private Authenticate auth;

    @Inject
    private AccountDetailGenerator accountDetailGenerator;

    @Inject
    private SecureTokenGenerator secureTokenGenerator;
    
    @Inject
    private PasswordManager passwordManager;

    @Inject
    private MailerManager mailerManager;
    
    @Inject
    private DateChecker dateChecker;
    
    @Inject
    private AccountOrganisationManager accountOrganisationManager;
    
    @Inject
    private AuthenticateManager authenticateManager;
    
    @Inject
    private SubjectRoleManager subjectRoleManager;


    public RegisterStatus register(AccountDTO accountDTO, List<RoleDTO> accountRoles) throws Exception{
        if(accountOrganisationManager.isMemberMax()){
            return RegisterStatus.FAILURE;
        }
        if (accountFacade.emailExist(accountDTO.getEmail())) {
            return RegisterStatus.EMAIL_EXIST;
        } else {
//            try {
                String hashPassword;
                if(accountDTO.getPassword()==null){
                    hashPassword = auth.passwordHasher(accountDetailGenerator.passwordGenerator());
                }else{
                    hashPassword = auth.passwordHasher(accountDTO.getPassword());
                }
                accountDTO.setPassword(hashPassword);
                Account account = accountDTO.toAccount();
                account.setSecretKey2FA(auth2FA.generateSecretKey()); //2FA Key
                EmailVerification emailVerification = createEmailVerification();
                account.setEmailVerification(emailVerification);
                account = passwordManager.generateAccountPasswordToken(account);
                accountFacade.create(account);
                if(subjectRoleManager.createMultiMapping(account.toDTO(), accountRoles)!=MappingStatus.SUCCESS){
                    accountFacade.remove(account);
                    return RegisterStatus.ERROR;
                }
                accountOrganisationManager.registerToOrganisation(accountDTO);
                //mailerManager.emailVerification(account); //Verification for signup
                mailerManager.newAccountPassword(account); //verification for invited 

//            } catch (Exception e) {
//                return RegisterStatus.FAILURE;
//            }
            return RegisterStatus.SUCCESS;

        }

    }
    
    
    public RegisterStatus registerWithoutOrganisation(AccountDTO accountDTO, List<RoleDTO> accountRoles) throws Exception{
        if(accountOrganisationManager.isMemberMax()){
            return RegisterStatus.FAILURE;
        }
        if (accountFacade.emailExist(accountDTO.getEmail())) {
            return RegisterStatus.EMAIL_EXIST;
        } else {
//            try {
                String hashPassword;
                if(accountDTO.getPassword()==null){
                    hashPassword = auth.passwordHasher(accountDetailGenerator.passwordGenerator());
                }else{
                    hashPassword = auth.passwordHasher(accountDTO.getPassword());
                }
                accountDTO.setPassword(hashPassword);
                Account account = accountDTO.toAccount();
                account.setSecretKey2FA(auth2FA.generateSecretKey()); //2FA Key
                EmailVerification emailVerification = createEmailVerification();
                account.setEmailVerification(emailVerification);
                account = passwordManager.generateAccountPasswordToken(account);
                accountFacade.create(account);
                if(subjectRoleManager.createMultiMapping(account.toDTO(), accountRoles)!=edu.mac.malwarereport.subjectassignment.outputinfo.MappingStatus.SUCCESS){
                    accountFacade.remove(account);
                    return RegisterStatus.ERROR;
                }
                mailerManager.newAccountPassword(account); //verification for invited 

//            } catch (Exception e) {
//                return RegisterStatus.FAILURE;
//            }
System.out.print("D15");
            return RegisterStatus.SUCCESS;

        }
    }
    
    
    
    //CHAANGE TO AUTO VERIFY ACCOUNT
    public ResetPasswordStatus activateNewAccount(AccountDTO accountDTO) {
        String token = accountDTO.getPasswordToken();
        String password = accountDTO.getPassword();
        try {
            PasswordToken passwordToken = passwordTokenFacade.getPasswordToken(token);            
            Date timeout = passwordToken.getTimestamp();
            //delete token
            Account account = accountFacade.getAccountByPasswordTokenId(passwordToken);
            EmailVerificationDTO emailVerificationDTO = new EmailVerificationDTO(account.getEmailVerification().getToken());
            switch (authenticateManager.emailVerification(emailVerificationDTO)){
                case SUCCESS:
                    account.setPassword(auth.passwordHasher(password));
                    passwordTokenFacade.remove(account.getPasswordToken());
                    account.setPasswordToken(null);
                    accountFacade.edit(account);
                    return ResetPasswordStatus.SUCCESS;
                case TOKEN_EXPIRE:
                    return ResetPasswordStatus.TIMEOUT;
                default:
                    return ResetPasswordStatus.FAILURE;
            }
        } catch (Exception e) {
            return ResetPasswordStatus.FAILURE;
        }

        //System.out.print(passwordToken.getAccount().getEmail());
        //System.out.print(passwordToken.getAccount().getEmail());
    }
    
    public OutcomeStatus updateAccount(AccountDTO accountDTO) {
        try {
            String suuid = accountDTO.getSuuid();
            Account account = accountFacade.getAccountBySuuid(suuid);
            String firstName = accountDTO.getFirstName();
            String lastName = accountDTO.getLastName();
            String email = accountDTO.getEmail();
            account.setFirstName(firstName);
            account.setLastName(lastName);
//            account.setEmail(email);
            accountFacade.edit(account);
            return OutcomeStatus.SUCCESS;
        } catch (Exception e) {
            return OutcomeStatus.ERROR;
        }
    }

    public EmailVerification createEmailVerification() {
        String emailVerificationToken = secureTokenGenerator.getToken();
        EmailVerification emailVerification = new EmailVerification(emailVerificationToken);
        return emailVerification;
    }    
    
    public OutcomeStatus delete(AccountDTO accountDTO){
        if(auth.getCurrentAccount().getSuuid().equals(accountDTO.getSuuid())){
            return OutcomeStatus.FAILURE;
        }
        try{
            String email = accountDTO.getEmail();
            Account account = accountFacade.getAccount(email);
            account.setDelete(true);
            accountFacade.edit(account);
            accountOrganisationManager.deleteMapping(accountDTO);
            subjectRoleManager.deleteAllMappingByAccount(accountDTO);
            return OutcomeStatus.SUCCESS;
        }catch(Exception e){
            //ERROR WHEN RETRIVING ACCOUNT
            return OutcomeStatus.ERROR;
        }
        
    }
    
    public AccountDTO getBySuuid(String suuid){
        return accountFacade.getAccountBySuuid(suuid).toDTO();
    }
    
    public AccountDTO getById(Long id){
        return accountFacade.find(id).toDTO();
    }

}

   
//    public RegisterStatus registerWithoutPassword(AccountDTO accountDTO) {
//        if (accountFacade.emailExist(accountDTO.getEmail())) {
//            return RegisterStatus.EMAIL_EXIST;
//        } else {
//            try {
//                String hashPassword = auth.passwordHasher(accountDetailGenerator.passwordGenerator());
//                accountDTO.setPassword(hashPassword);
//                Account account = accountDTO.toAccount();
//                account.setSecretKey2FA(auth2FA.generateSecretKey()); //2FA Key
//                EmailVerification emailVerification = createEmailVerification();
//                account.setEmailVerification(emailVerification);
//                accountFacade.create(account);
//                mailerManager.newAccountPassword(account);
//            } catch (Exception e) {
//                return RegisterStatus.FAILURE;
//            }
//            return RegisterStatus.SUCCESS;
//
//        }
//
//    }
