/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package edu.mac.malwarereport.role.manager;

import edu.mac.malwarereport.account.authenticate.Authenticate;
import edu.mac.malwarereport.account.ownershipassignment.mapper.AccountOrganisationMapper;
import edu.mac.malwarereport.organisation.data.OrganisationFacade;
import edu.mac.malwarereport.organisation.dto.OrganisationDTO;
import edu.mac.malwarereport.permission.dto.PermissionDTO;
import edu.mac.malwarereport.role.data.RoleFacade;
import edu.mac.malwarereport.role.dto.RoleDTO;
import edu.mac.malwarereport.role.entity.Role;
import edu.mac.malwarereport.role.outputInfo.RoleMappingStatus;
import edu.mac.malwarereport.role.outputInfo.OutcomeStatus;
import edu.mac.malwarereport.role.ownershipassignment.manager.RoleOrganisationManager;
import edu.mac.malwarereport.role.ownershipassignment.mapper.RoleOrganisationMapper;
import edu.mac.malwarereport.role.permissionassignment.manager.RolePermissionManager;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author tohyu
 */
@Stateless
public class RoleManager {
    
    @Inject
    private RoleFacade roleFacade;
    
    @Inject
    private RoleOrganisationMapper roleOrganisationmapper;
    
    @Inject
    private Authenticate authenticate;
    
    @Inject
    private RoleOrganisationMapper roleOrganisationMapper;
    
    @Inject
    private RoleOrganisationManager roleOrganisationManager;
    
    @Inject
    private RolePermissionManager rolePermissionManager;
    
    @Inject
    private AccountOrganisationMapper accountOrganisationMapper;
    
    @Inject
    private OrganisationFacade organisationFacade;
    
     //find individual account 
    public RoleDTO findbyID(long id){
        Role role = roleFacade.find(id);
        return role.toDTO();
    }
    
    public RoleDTO findBySuuid(RoleDTO roleDTO){
        String suuid = roleDTO.getSuuid();
        Role role = roleFacade.getRoleBySuuid(suuid);
        return role.toDTO();
    }
    
    //find all the accounts
    public List<RoleDTO> findAll(){
        List<Role> roleList = roleFacade.findAll();
        List<RoleDTO> roleDTOList = new ArrayList<>();
        for (int i =0; i < roleList.size(); i++){
            RoleDTO tempRole = roleList.get(i).toDTO();
            roleDTOList.add(tempRole);
        }
        return roleDTOList;
    }
    
    public RoleMappingStatus create(RoleDTO roleDTO, List<PermissionDTO> permissionDTOList){
        long accountId = authenticate.getCurrentAccount().getId();
        long organisationId = accountOrganisationMapper.getOrganisationId(accountId);
        if(roleOrganisationMapper.isRoleNameExist(roleDTO.getName(), organisationId)){
            return RoleMappingStatus.EXIST;
        }
        //Obtain existing children frm db
        List<Role> childrenList = new ArrayList<>();
        for(RoleDTO childrenDTO:roleDTO.getChildren()){
            Role tempChild = roleFacade.getRoleBySuuid(childrenDTO.getSuuid());
            childrenList.add(tempChild);
            if(tempChild.getSuuid().equalsIgnoreCase(roleDTO.getSuuid())){
                return RoleMappingStatus.INVALID_INPUT_SELF;
            }
        }
        //get all indirect inheritance 
        List<RoleDTO> indirectInheritance = new ArrayList<>();
        for(RoleDTO eachChildren : roleDTO.getChildren()){
            for(RoleDTO eachInheritance : eachChildren.getInheritance(eachChildren)){
                indirectInheritance.add(eachInheritance);
            }
        }
        //reject if validation is not met
        for(RoleDTO eachInherit : roleDTO.getChildren()){
            //check for child for repeat
            for(RoleDTO eachIndirectInheritence : indirectInheritance){
                System.out.print("IndirectInheritence: " + eachIndirectInheritence.getName());
                if(eachIndirectInheritence.getSuuid().equalsIgnoreCase(eachInherit.getSuuid())){
                    return RoleMappingStatus.INVALID_INHERITANCE;
                }
            }
        }
        Role role = roleDTO.toObject();
        role.setChildren(childrenList);
        //Permission
        //persist
        try{
            roleFacade.create(role);
            long roleId = role.getId();
                if(roleOrganisationMapper.createMapping(organisationId, roleId)==RoleMappingStatus.SUCCESS){
                    if(permissionDTOList.size()>0){
                        System.out.print("Role: " + role.toDTO().getName() + "\nPermission: ");
                        for(PermissionDTO tempPermissionDTO : permissionDTOList){
                            System.out.print(tempPermissionDTO.getName());
                        }
                        rolePermissionManager.createMultiMapping(role.toDTO(), permissionDTOList);
                }
            }
            
            return RoleMappingStatus.SUCCESS;
        }catch (Exception e){
            roleOrganisationManager.deleteMapping(role.toDTO());
            return RoleMappingStatus.ERROR;
        }
    }
    
    public RoleMappingStatus createByAdmin(RoleDTO roleDTO, List<PermissionDTO> permissionDTOList, OrganisationDTO organisationDTO){
        long organisationId = organisationFacade.getOrganisationBySuuid(organisationDTO.getSuuid()).getId();
        if(roleOrganisationMapper.isRoleNameExist(roleDTO.getName(), organisationId)){
            return RoleMappingStatus.EXIST;
        }
        //Obtain existing children frm db
        List<Role> childrenList = new ArrayList<>();
        for(RoleDTO childrenDTO:roleDTO.getChildren()){
            Role tempChild = roleFacade.getRoleBySuuid(childrenDTO.getSuuid());
            childrenList.add(tempChild);
            if(tempChild.getSuuid().equalsIgnoreCase(roleDTO.getSuuid())){
                return RoleMappingStatus.INVALID_INPUT_SELF;
            }
        }
        //get all indirect inheritance 
        List<RoleDTO> indirectInheritance = new ArrayList<>();
        for(RoleDTO eachChildren : roleDTO.getChildren()){
            for(RoleDTO eachInheritance : eachChildren.getInheritance(eachChildren)){
                indirectInheritance.add(eachInheritance);
            }
        }
        //reject if validation is not met
        for(RoleDTO eachInherit : roleDTO.getChildren()){
            //check for child for repeat
            for(RoleDTO eachIndirectInheritence : indirectInheritance){
                System.out.print("IndirectInheritence: " + eachIndirectInheritence.getName());
                if(eachIndirectInheritence.getSuuid().equalsIgnoreCase(eachInherit.getSuuid())){
                    return RoleMappingStatus.INVALID_INHERITANCE;
                }
            }
        }
        Role role = roleDTO.toObject();
        role.setChildren(childrenList);
        //Permission
        //persist
        try{
            roleFacade.create(role);
            long roleId = role.getId();
                if(roleOrganisationMapper.createMapping(organisationId, roleId)==RoleMappingStatus.SUCCESS){
                    if(permissionDTOList.size()>0){
                        System.out.print("Role: " + role.toDTO().getName() + "\nPermission: ");
                        for(PermissionDTO tempPermissionDTO : permissionDTOList){
                            System.out.print(tempPermissionDTO.getName());
                        }
                        rolePermissionManager.createMultiMapping(role.toDTO(), permissionDTOList);
                }
            }
            
            return RoleMappingStatus.SUCCESS;
        }catch (Exception e){
            roleOrganisationManager.deleteMapping(role.toDTO());
            return RoleMappingStatus.ERROR;
        }
    }
    
    public RoleMappingStatus update(RoleDTO roleDTO, List<PermissionDTO> permissionDTOList){
        long accountId = authenticate.getCurrentAccount().getId();
        long organisationId = accountOrganisationMapper.getOrganisationId(accountId);
        String suuid = roleDTO.getSuuid();
        Role currentRole = roleFacade.getRoleBySuuid(suuid);
        if(roleOrganisationmapper.isRoleNameExistOnUpdate(currentRole.getId(), roleDTO.getName())){
            return RoleMappingStatus.EXIST;
        }
        String name = roleDTO.getName();
        String description = roleDTO.getDescription();
        List<Role> childrenList = new ArrayList<>();
        
        //check if it is self //ONLY obtain surface inheritance
        for(RoleDTO childrenDTO:roleDTO.getChildren()){
//            System.out.print("CHILDRENS: " + roleDTO.getChildren().size());
            Role tempRole = roleFacade.getRoleBySuuid(childrenDTO.getSuuid());
            if(tempRole.getSuuid().equalsIgnoreCase(suuid)){
                return RoleMappingStatus.INVALID_INPUT_SELF;
            }
//            if(tempRole.getSuuid() : )
            childrenList.add(tempRole);
        }
        //get all indirect inheritance 
        List<RoleDTO> indirectInheritance = new ArrayList<>();
        for(RoleDTO eachChildren : roleDTO.getChildren()){
            for(RoleDTO eachInheritance : eachChildren.getInheritance(eachChildren)){
                indirectInheritance.add(eachInheritance);
            }
        }
        List<RoleDTO> inheritedBy = roleDTO.getAllInheritedBy(roleDTO);
        //reject if validation is not met
        for(RoleDTO eachInherit : roleDTO.getChildren()){
            //check for child for repeat
            for(RoleDTO eachIndirectInheritence : indirectInheritance){
//                System.out.print("IndirectInheritence: " + eachIndirectInheritence.getName());
                if(eachIndirectInheritence.getSuuid().equalsIgnoreCase(eachInherit.getSuuid())){
                    return RoleMappingStatus.INVALID_INHERITANCE;
                }
            }
            //Check for inheritance loop
            for(RoleDTO eachParent : inheritedBy){
//                System.out.print("eachParent: " + eachParent.getName());
                if(eachParent.getSuuid().equalsIgnoreCase(eachInherit.getSuuid())){
                    return RoleMappingStatus.INVALID_INHERITANCE;
                }
            }
        }
        try{
            currentRole.setName(name);
            currentRole.setDescription(description);
            currentRole.setChildren(childrenList);
            roleFacade.edit(currentRole);
            long roleId = currentRole.getId();
            System.out.print("Role: " + currentRole.toDTO().getName() + "\nPermission: ");
            for(PermissionDTO tempPermissionDTO : permissionDTOList){
                System.out.print(tempPermissionDTO.getName());
            }
            rolePermissionManager.createMultiMapping(currentRole.toDTO(), permissionDTOList);
            
            
            
        return RoleMappingStatus.SUCCESS;
        }catch (Exception e){
            roleOrganisationManager.deleteMapping(currentRole.toDTO());
            return RoleMappingStatus.ERROR;
        }
    }
    
//    private boolean containsName(final List<RoleDTO> list, final String suuid) {
//        return list.stream().map(RoleDTO::getSuuid).filter(suuid::equals).findFirst().isPresent();
//    }
    
    public OutcomeStatus delete(RoleDTO roleDTO){
        try{
        Role role = roleFacade.getRoleBySuuid(roleDTO.getSuuid());
        roleFacade.remove(role);
        return OutcomeStatus.SUCCESS;
        }catch (Exception e){
            return OutcomeStatus.ERROR;
        }
    }
    
}
